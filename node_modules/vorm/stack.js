

class Stack {

constructor(options={}) {
this.isChain = options.connection ? true: false;
this.connection = options.connection ? options.connection : null;
this.sql = []; this.params = [];
this.driver = options.driver;
this.blueprint = d => options.blueprint;
this.database = options.database;
this.functions = ["now()"];
}

select(fields, distinct) {
fields = (fields.join ? fields.join(",") : fields).replace(/([.a-zA-Z0-9()@_]+)/g, (match,field) => {
return this.functions.includes(field) ? field : `\`${field}\``; });
this.sql = [`SELECT ${distinct ? "DISTINCT" : ""} ${fields}`];
return this;
}

delete() {
this.sql.push("DELETE");
return this;
}

limit(limit) {
this.sql.push(`LIMIT ${limit}`);
return this;
}

order(columns, order="ASC") {
columns = (columns.join ? columns.join(",") : columns).replace(/([.A-Za-z0-9]+)/, (match,column) => { return `\`${column}\``; });
this.sql.push(`ORDER BY ${columns} ${order}`);
return this;
}

group(groups) {
groups = (groups.join ? groups.join(",") : groups).replace(/([.A-Za-z0-9]+)/, (match,order) => { return `\`${order}\``; });
this.sql.push(`GROUP BY ${order}`);
return this;
}

count(columns) {
this.sql.push(`COUNT(${columns.join ? columns.join(",") : columns})`);
return this
}

from(tables) {
this.sql.push(`FROM ${tables.join ? tables.join(",") : tables}`);
return this;
}

insert() {
this.sql.push(`INSERT`);
return this;
}

into(table) {
this.sql.push(`INTO \`${table}\``);
return this;
}

columns(columns) {
columns = (columns.join ? columns.join(",") : columns).replace(/([.A-Za-z0-9()_]+)/g, (match, column) => { return `\`${column}\`` });
this.sql.push(`(${columns})`);
return this;
}

values(values) {
let sql = "VALUES(";
values.forEach((value,i) => {
if(/`/.test(value)) {
sql += `${value.replace(/`/g,"")}${i===values.length-1 ? "" : ","}`;
} else {
sql += `?${i===values.length-1 ? "" : ","}`;
this.params.push(value);
}});
sql +=")";
this.sql.push(sql);
return this;
}

update(table){
this.sql.push(`UPDATE \`${table}\``);
return this;
}

set(columnsAndValues) {
let columns = [];
let values = [];
let entries = Array.from(Object.entries(columnsAndValues));
let sql = "SET ";
entries.forEach((column,i) => {
if(/`/.test(column[1])) {
sql += `${column[0]}=${column[1].replace(/`/g,"")}${i === entries.length-1 ? "" : ","}`;
} else {
sql += `${column[0]}=?${i!==entries.length-1 ? " , " : ""}`; 
this.params.push(column[1]); }
});
this.sql.push(sql);
return this;
}

where(columnsAndValues) {
let columns = [];
let values = [];
let entries = Array.from(Object.entries(columnsAndValues));
let sql = "WHERE ";
entries.forEach((column,i) => {
sql += `\`${column[0]}\`${column[1].operand ? column[1].operand : "="}${ column[1].special ? column[1].is : "?" }${i!==entries.length-1 ? " AND " : ""}`;
column[1].special ? "" : this.params.push(column[1].is);
});
this.sql.push(sql);
return this;
}

case(clause) {
let sql = "";
let entries = Array.from(Object.entries(clause));
entries.forEach((column,i) => {
sql += `\`${column[0]}\`${column[1].operand ? column[1].operand : "="}${column[1].is}${i!==entries.length-1 ? " AND " : ""}`;
});
this.sql.push(sql);
return this;
}
and() { this.sql.push("AND"); return this; }
_() { this.sql.push("OR"); return this; }
openBrace() { this.sql.push("("); return this }
closeBrace() { this.sql.push(")"); return this }

like(row) {
row = Object.entries(row)[0];
this.params.push(row[1]);
this.sql.push(`${row[0]} LIKE ?`);
return this;
}

as(alias) {
this.sql.push(`AS ${alias.join ? alias.join(',') : alias }`);
return this;
}

or(columnsAndValues) {
let columns = [];
let values = [];
let entries = Array.from(Object.entries(columnsAndValues));
let sql = "OR ";
entries.forEach((column,i) => {
sql += `${column[0]}${column[1].operand ? column[1].operand : "="}?${i!==entries.length-1 ? " AND " : ""}`; 
this.params.push(column[1].is);
});
this.sql.push(sql);
return this;
}


async sync(callback) {
let connection = this.connection ? this.connection : await this.driver().use(this.database);
let results = await this.driver().run(this.sql.join(" "), connection, this.params, this.isChain ? false : true);
this.sql = this.isChain ? [] : this.sql;
this.params = this.isChain ? [] : this.params;
return results;
}


}

module.exports = Stack;